1.Search in BST.
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
        if(root == null){
            return null ;
        }
        TreeNode curr = root;
        while(curr != null && curr.data != val){
            if(curr.data > val){
                curr = curr.left;
            }
            else{
                curr = curr.right;
            }
        }
        return curr;
    }
}
2.Floor And Ceil in BST.
class Solution {
    public List<Integer> floorCeilOfBST(TreeNode root, int key) {
        int floor = -1;
        int ceil = -1;
        TreeNode current = root;  
        while (current != null) {
            if (current.data == key) {
                floor = current.data;  
                break;    
            } else if (current.data < key) {   
                floor = current.data;   
                current = current.right;  
            } else {  
                current = current.left;   
            }
        }
        current = root;  
        while (current != null) {
            if (current.data == key) {  
                ceil = current.data;  
                break;
            } else if (current.data > key) {  
                ceil = current.data;  
                current = current.left;  
            } else {  
                current = current.right;  
            }
        }
        return Arrays.asList(floor, ceil);
    }
}    
3.Insertion a given val node in BST.
class Solution {
    public TreeNode insertIntoBST(TreeNode root, int val) {
        if(root == null){
            return new TreeNode (val);
        }
        TreeNode curr = root;
        while(curr != null){
            if(curr.data <= val){
                if(curr.right != null){
                    curr = curr.right;
                }
                else{
                    curr.right = new TreeNode(val);
                    break;
                }
            }
            else{
                if(curr.left != null){
                    curr = curr.left;
                }
                else{
                    curr.left = new TreeNode(val);
                    break;
                }
            }
        }
        return root;
    }
}
4.Delete a node in BST
class Solution {
    private TreeNode connector(TreeNode root) {
        if (root.left == null) return root.right;
        if (root.right == null) return root.left;
        TreeNode leftChild = root.left;
        TreeNode leftmostChildInRightSubtree = root.right;
        while (leftmostChildInRightSubtree.left != null) {
            leftmostChildInRightSubtree = leftmostChildInRightSubtree.left;
        }
        leftmostChildInRightSubtree.left = leftChild;
        return root.right;
    }
    public TreeNode deleteNode(TreeNode root, int key) {
        if (root == null) return null;
        if (root.data == key) {
            return connector(root);
        }
        TreeNode node = root;
        while (node != null) {
            if (node.data > key) {
                if (node.left != null && node.left.data == key) {
                    node.left = connector(node.left);
                    break;
                } else {
                    node = node.left; 
                }
            }
            else {
                if (node.right != null && node.right.data == key) {
                    node.right = connector(node.right);
                    break;
                } else {
                    node = node.right; 
                }
            }
        }
        return root;
    }
}
4.Kth Smallest and Largest element in BST.
class Solution {
    private int k;
    private int result;
    public int kthSmallest(TreeNode root, int k) {
        this.k = k;
        this.result = -1;
        inorder(root);
        return result;
    }
    private void inorder(TreeNode node) {
        if (node != null) {
            inorder(node.left);
            if (--k == 0) {
                result = node.data;
                return;
            }
            inorder(node.right);
        }
    }
    public int kthLargest(TreeNode root, int k) {
        this.k = k;
        this.result = -1;
        reverseInorder(root);
        return result;
    }
    private void reverseInorder(TreeNode node) {
        if (node != null) {
            reverseInorder(node.right);
            if (--k == 0) {
                result = node.data;
                return;
            }
            reverseInorder(node.left);
        }
    }
    public List<Integer> kLargesSmall(TreeNode root, int k) {
        List<Integer> result = new ArrayList<>();
        result.add(kthSmallest(root, k));
        result.add(kthLargest(root, k));
        return result;
    }
}
4.Check if a tree is a BST or not.
class Solution {
    public boolean isBST(TreeNode root) {
        return validate(root, Long.MIN_VALUE, Long.MAX_VALUE);
    }
    private boolean validate(TreeNode node, long min, long max) {
        if (node == null) return true;        
        if (node.data <= min || node.data >= max) return false;        
        boolean leftIsValid = validate(node.left, min, node.data);        
        boolean rightIsValid = validate(node.right, node.data, max);
        return leftIsValid && rightIsValid;
    }
}
5.LCA in BST.
class Solution { 
    TreeNode lca(TreeNode root, int p, int q) {
        if (root == null) return null;
        int curr = root.data;
        if (curr < p && curr < q)
            return lca(root.right, p, q);
        if (curr > p && curr > q)
            return lca(root.left, p, q);
        return root;
    }
}
6.Two Sum in BST.
class Solution {
    public boolean twoSumBST(TreeNode root, int k) {
        List<Integer> sorted_List = inorderTraversal(root);
        int i = 0, j = sorted_List.size() - 1;
        while (i < j) {
            int current_num = sorted_List.get(i) + sorted_List.get(j);
            if (current_num == k) {
                return true;
            } else if (current_num < k) {
                i++;
            } else {
                j--;
            }
        }
        return false;
    }
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> ele = new ArrayList<>();
        inorderHelper(root, ele);
        return ele;
    }
    public void inorderHelper(TreeNode node, List<Integer> ele) {
        if (node == null) {
            return;
        }
        inorderHelper(node.left, ele);
        ele.add(node.data);
        inorderHelper(node.right, ele);
    }
}
7.Correct BST with two nodes swapped.
class Solution {
    List<Integer> inorderValues = new ArrayList<>();
    int index = 0;
    public void recoverTree(TreeNode root) {
        collectInorder(root);
        Collections.sort(inorderValues);
        restoreInorder(root);
    }
    private void collectInorder(TreeNode root) {
        if (root == null) return;
        collectInorder(root.left);
        inorderValues.add(root.data);
        collectInorder(root.right);
    }
    private void restoreInorder(TreeNode root) {
        if (root == null) return;
        restoreInorder(root.left);
        root.data = inorderValues.get(index++);
        restoreInorder(root.right);
    }
}
8.Largest BST in Binary Tree.
class Solution {
    public int largestBST(TreeNode root) {
        if (root == null) return 0;
        if (isBST(root, Integer.MIN_VALUE, Integer.MAX_VALUE)) {
            return getSize(root);
        }
        return Math.max(largestBST(root.left), largestBST(root.right));
    }
    private boolean isBST(TreeNode root, int min, int max) {
        if (root == null) return true;
        if (root.data <= min || root.data >= max) return false;
        return isBST(root.left, min, root.data) && isBST(root.right, root.data, max);
    }
    private int getSize(TreeNode root) {
        if (root == null) return 0;
        return 1 + getSize(root.left) + getSize(root.right);
    }
}
