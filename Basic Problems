1.Search in BST.
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
        if(root == null){
            return null ;
        }
        TreeNode curr = root;
        while(curr != null && curr.data != val){
            if(curr.data > val){
                curr = curr.left;
            }
            else{
                curr = curr.right;
            }
        }
        return curr;
    }
}
2.Floor And Ceil in BST.
class Solution {
    public List<Integer> floorCeilOfBST(TreeNode root, int key) {
        int floor = -1;
        int ceil = -1;
        TreeNode current = root;  
        while (current != null) {
            if (current.data == key) {
                floor = current.data;  
                break;    
            } else if (current.data < key) {   
                floor = current.data;   
                current = current.right;  
            } else {  
                current = current.left;   
            }
        }
        current = root;  
        while (current != null) {
            if (current.data == key) {  
                ceil = current.data;  
                break;
            } else if (current.data > key) {  
                ceil = current.data;  
                current = current.left;  
            } else {  
                current = current.right;  
            }
        }
        return Arrays.asList(floor, ceil);
    }
}    
3.Insertion a given val node in BST.
class Solution {
    public TreeNode insertIntoBST(TreeNode root, int val) {
        if(root == null){
            return new TreeNode (val);
        }
        TreeNode curr = root;
        while(curr != null){
            if(curr.data <= val){
                if(curr.right != null){
                    curr = curr.right;
                }
                else{
                    curr.right = new TreeNode(val);
                    break;
                }
            }
            else{
                if(curr.left != null){
                    curr = curr.left;
                }
                else{
                    curr.left = new TreeNode(val);
                    break;
                }
            }
        }
        return root;
    }
}
4.Delete a node in BST
class Solution {
    private TreeNode connector(TreeNode root) {
        if (root.left == null) return root.right;
        if (root.right == null) return root.left;
        TreeNode leftChild = root.left;
        TreeNode leftmostChildInRightSubtree = root.right;
        while (leftmostChildInRightSubtree.left != null) {
            leftmostChildInRightSubtree = leftmostChildInRightSubtree.left;
        }
        leftmostChildInRightSubtree.left = leftChild;
        return root.right;
    }
    public TreeNode deleteNode(TreeNode root, int key) {
        if (root == null) return null;
        if (root.data == key) {
            return connector(root);
        }
        TreeNode node = root;
        while (node != null) {
            if (node.data > key) {
                if (node.left != null && node.left.data == key) {
                    node.left = connector(node.left);
                    break;
                } else {
                    node = node.left; 
                }
            }
            else {
                if (node.right != null && node.right.data == key) {
                    node.right = connector(node.right);
                    break;
                } else {
                    node = node.right; 
                }
            }
        }
        return root;
    }
}
4.Kth Smallest and Largest element in BST.
class Solution {
    private int k;
    private int result;
    public int kthSmallest(TreeNode root, int k) {
        this.k = k;
        this.result = -1;
        inorder(root);
        return result;
    }
    private void inorder(TreeNode node) {
        if (node != null) {
            inorder(node.left);
            if (--k == 0) {
                result = node.data;
                return;
            }
            inorder(node.right);
        }
    }
    public int kthLargest(TreeNode root, int k) {
        this.k = k;
        this.result = -1;
        reverseInorder(root);
        return result;
    }
    private void reverseInorder(TreeNode node) {
        if (node != null) {
            reverseInorder(node.right);
            if (--k == 0) {
                result = node.data;
                return;
            }
            reverseInorder(node.left);
        }
    }
    public List<Integer> kLargesSmall(TreeNode root, int k) {
        List<Integer> result = new ArrayList<>();
        result.add(kthSmallest(root, k));
        result.add(kthLargest(root, k));
        return result;
    }
}
4.Check if a tree is a BST or not.
class Solution {
    public boolean isBST(TreeNode root) {
        return validate(root, Long.MIN_VALUE, Long.MAX_VALUE);
    }
    private boolean validate(TreeNode node, long min, long max) {
        if (node == null) return true;        
        if (node.data <= min || node.data >= max) return false;        
        boolean leftIsValid = validate(node.left, min, node.data);        
        boolean rightIsValid = validate(node.right, node.data, max);
        return leftIsValid && rightIsValid;
    }
}
