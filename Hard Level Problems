1.Construct a BST from a preorder traversal
class Solution {
    public TreeNode bstFromPreorder(int[] preorder) {
        return bstFromPreorderHelper(preorder, Integer.MAX_VALUE, new int[]{0});
    }
    private TreeNode bstFromPreorderHelper(int[] preorder, int bound, int[] index) {
        if (index[0] == preorder.length || preorder[index[0]] > bound) return null;
        TreeNode root = new TreeNode(preorder[index[0]++]);
        root.left = bstFromPreorderHelper(preorder, root.data, index);
        root.right = bstFromPreorderHelper(preorder, bound, index);
        return root;
    }
}
2.Inorder successor and predecessor in BST.
class Solution {
    public int[] succPredBST(TreeNode root, int key) {
        TreeNode predecessor = null;
        TreeNode successor = null;
        TreeNode curr = root;
        while (curr != null) {
            if (key > curr.data) {
                predecessor = curr;
                curr = curr.right;
            } else if (key < curr.data) {
                successor = curr;
                curr = curr.left;
            } else {               
                if (curr.left != null) {
                    TreeNode temp = curr.left;
                    while (temp.right != null)
                        temp = temp.right;
                    predecessor = temp;
                }
                if (curr.right != null) {
                    TreeNode temp = curr.right;
                    while (temp.left != null)
                        temp = temp.left;
                    successor = temp;
                }
                break;
            }
        }
        int predVal = (predecessor != null ? predecessor.data : -1);
        int succVal = (successor != null ? successor.data : -1);
        return new int[]{predVal, succVal};
    }
}
3.BST Iterator.
class BSTIterator {
    private Stack<TreeNode> stack = new Stack<>();    
    public BSTIterator(TreeNode root) {
        pushAll(root);
    }
    public boolean hasNext() {
        return !stack.isEmpty();
    }
    public int next() {
        TreeNode temp = stack.pop();
        pushAll(temp.right);
        return temp.data;
    }
    private void pushAll(TreeNode node) {
        while (node != null) {
            stack.push(node);
            node = node.left;
        }
    }
}
4.Two sum in BST.
class BSTIterator {
    private Stack<TreeNode> stack = new Stack<>();
    private boolean reverse;
    public BSTIterator(TreeNode root, boolean isReverse) {
        reverse = isReverse;
        pushAll(root);
    }
    private void pushAll(TreeNode node) {
        while (node != null) {
            stack.push(node);
            node = (reverse) ? node.right : node.left;
        }
    }
    public boolean hasNext() {
        return !stack.isEmpty();
    }
    public int next() {
        TreeNode node = stack.pop();
        if (!reverse) pushAll(node.right);
        else pushAll(node.left);
        return node.data;
    }
}
class Solution {
    public boolean twoSumBST(TreeNode root, int k) {
        if (root == null) return false;
        BSTIterator l = new BSTIterator(root, false); 
        BSTIterator r = new BSTIterator(root, true);  
        int i = l.next();
        int j = r.next();
        while (i < j) {
            if (i + j == k) return true;
            else if (i + j < k) i = l.next();
            else j = r.next();
        }
        return false;
    }
}
