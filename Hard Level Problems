1.Construct a BST from a preorder traversal
class Solution {
    public TreeNode bstFromPreorder(int[] preorder) {
        return bstFromPreorderHelper(preorder, Integer.MAX_VALUE, new int[]{0});
    }
    private TreeNode bstFromPreorderHelper(int[] preorder, int bound, int[] index) {
        if (index[0] == preorder.length || preorder[index[0]] > bound) return null;
        TreeNode root = new TreeNode(preorder[index[0]++]);
        root.left = bstFromPreorderHelper(preorder, root.data, index);
        root.right = bstFromPreorderHelper(preorder, bound, index);
        return root;
    }
}
2.Inorder successor and predecessor in BST.
class Solution {
    public int[] succPredBST(TreeNode root, int key) {
        TreeNode predecessor = null;
        TreeNode successor = null;
        TreeNode curr = root;
        while (curr != null) {
            if (key > curr.data) {
                predecessor = curr;
                curr = curr.right;
            } else if (key < curr.data) {
                successor = curr;
                curr = curr.left;
            } else {               
                if (curr.left != null) {
                    TreeNode temp = curr.left;
                    while (temp.right != null)
                        temp = temp.right;
                    predecessor = temp;
                }
                if (curr.right != null) {
                    TreeNode temp = curr.right;
                    while (temp.left != null)
                        temp = temp.left;
                    successor = temp;
                }
                break;
            }
        }
        int predVal = (predecessor != null ? predecessor.data : -1);
        int succVal = (successor != null ? successor.data : -1);
        return new int[]{predVal, succVal};
    }
}
